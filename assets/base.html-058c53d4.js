import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,e}from"./app-ec8b5cef.js";const p={},t=e(`<h2 id="webpack-模块打包运行原理" tabindex="-1"><a class="header-anchor" href="#webpack-模块打包运行原理" aria-hidden="true">#</a> webpack 模块打包运行原理？</h2><p>首先我们应该简单了解一下 webpack 的整个打包流程：</p><ol><li>读取 webpack 的配置参数；</li><li>启动 webpack，创建 Compiler 对象并开始解析项目；</li><li>从入口文件（entry）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；</li><li>对不同文件类型的依赖模块文件使用对应的 Loader 进行编译，最终转为 Javascript 文件；</li><li>整个过程中 webpack 会通过发布订阅模式，向外抛出一些 hooks，而 webpack 的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。</li></ol><p>其中文件的解析与构建是一个比较复杂的过程，在 webpack 源码中主要依赖于 compiler 和 compilation 两个核心对象实现。</p><p>compiler 对象是一个全局单例，他负责把控整个 webpack 打包的构建流程。</p><p>compilation 对象是每一次构建的上下文对象，它包含了当次构建所需要的所有信息，每次热更新和重新构建，compiler 都会重新生成一个新的 compilation 对象，负责此次更新的构建过程。</p><p>而每个模块间的依赖关系，则依赖于 AST 语法树。</p><p>每个模块文件在通过 Loader 解析完成之后，会通过 acorn 库生成模块代码的 AST 语法树，通过语法树就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。</p><p>最终 Webpack 打包出来的 bundle 文件是一个 IIFE 的执行函数。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// webpack 5 打包的bundle文件内容</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// webpackBootstrap</span>
    <span class="token keyword">var</span> __webpack_modules__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token string-property property">&#39;file-A-path&#39;</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">modules</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// ... })</span>
        <span class="token string-property property">&#39;index-file-path&#39;</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">__unused_webpack_module<span class="token punctuation">,</span> __unused_webpack_exports<span class="token punctuation">,</span> __webpack_require__</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// ... })</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// The module cache</span>
    <span class="token keyword">var</span> __webpack_module_cache__ <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// The require function</span>
    <span class="token keyword">function</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span><span class="token parameter">moduleId</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Check if module is in cache</span>
        <span class="token keyword">var</span> cachedModule <span class="token operator">=</span> __webpack_module_cache__<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cachedModule <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> cachedModule<span class="token punctuation">.</span>exports<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// Create a new module (and put it into the cache)</span>
        <span class="token keyword">var</span> module <span class="token operator">=</span> __webpack_module_cache__<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
                <span class="token comment">// no module.id needed</span>
                <span class="token comment">// no module.loaded needed</span>
                <span class="token literal-property property">exports</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// Execute the module function</span>
        __webpack_modules__<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">,</span> __webpack_require__ <span class="token string">&quot;moduleId&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Return the exports of the module</span>
        <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// startup</span>
    <span class="token comment">// Load entry module and return exports</span>
    <span class="token comment">// This entry module can&#39;t be inlined because the eval devtool is used.</span>
    <span class="token keyword">var</span> __webpack_exports__ <span class="token operator">=</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span><span class="token string">&quot;./src/index.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和 webpack4 相比，webpack5 打包出来的 bundle 做了相当的精简。</p><p>在上面的打包 demo 中，整个立即执行函数里边只有三个变量和一个函数方法，<strong>webpack_modules</strong>存放了编译后的各个文件模块的 JS 内容，<strong>webpack_module_cache</strong> 用来做模块缓存，<strong>webpack_require</strong>是 Webpack 内部实现的一套依赖引入函数。最后一句则是代码运行的起点，从入口文件开始，启动整个项目。</p><p>其中值得一提的是<strong>webpack_require</strong>模块引入函数，我们在模块化开发的时候，通常会使用 ES Module 或者 CommonJS 规范导出/引入依赖模块，webpack 打包编译的时候，会统一替换成自己的<strong>webpack_require</strong>来实现模块的引入和导出，从而实现模块缓存机制，以及抹平不同模块规范之间的一些差异性。</p>`,13),o=[t];function c(l,i){return s(),a("div",null,o)}const d=n(p,[["render",c],["__file","base.html.vue"]]);export{d as default};
