import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as p,c as u,a as n,b as s,d as t,e as a}from"./app-c0775de9.js";const i={},l=a(`<h2 id="官方文档" tabindex="-1"><a class="header-anchor" href="#官方文档" aria-hidden="true">#</a> 官方文档</h2><h3 id="useeffect" tabindex="-1"><a class="header-anchor" href="#useeffect" aria-hidden="true">#</a> useEffect</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span>didUpdate<span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">[</span>dep<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li><p>赋值给 <code>useEffect</code> 的函数 didUpdate 会在<u>组件渲染到屏幕之后</u>执行。 即待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code> 。</p></li><li><p>清除函数（didUpdate的返回值）。 为防止内存泄漏，清除函数会<u>在组件卸载前执行</u>。 如果组件多次渲染（通常如此），则<strong>在执行下一个 effect 之前，上一个 effect 就已被清除</strong>。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>useEffect(() =&gt; {
  const subscription = props.source.subscribe();
  return () =&gt; {
    // 清除订阅
    subscription.unsubscribe();
  };
});
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 不同的是，在浏览器完成布局与绘制<strong>之后</strong>，传给 <code>useEffect</code> 的函数<u>会延迟调用</u>。</p></li><li><p>虽然 <code>useEffect</code> 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。</p></li></ol>`,4),d={href:"https://react.docschina.org/docs/hooks-reference.html#useeffect",target:"_blank",rel:"noopener noreferrer"},r=a(`<h3 id="uselayouteffect" tabindex="-1"><a class="header-anchor" href="#uselayouteffect" aria-hidden="true">#</a> useLayoutEffect</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>useLayoutEffect(didUpdate[,[dep]]);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ 其函数签名与 <code>useEffect</code> 相同，但它<u>会在所有的 DOM 变更之后同步调用 effect</u>。可以使用它来<u><strong>读取 DOM 布局并同步触发重渲染</strong></u>。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p><p>​ 尽可能使用标准的 useEffect 以避免阻塞视觉更新。</p>`,4),k=a("<p><strong>提示</strong></p><p>如果你正在将代码从 class 组件迁移到使用 Hook 的函数组件，则<u>需要注意 <code>useLayoutEffect</code> 与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 的调用阶段是一样的</u>。但是，我们推荐你<strong>一开始先用 <code>useEffect</code></strong>，只有当它出问题的时候再尝试使用 <code>useLayoutEffect</code>。</p>",2),f={href:"https://react.docschina.org/docs/hooks-reference.html#uselayouteffect",target:"_blank",rel:"noopener noreferrer"},v=a(`<h2 id="最大的不同" tabindex="-1"><a class="header-anchor" href="#最大的不同" aria-hidden="true">#</a> 最大的不同</h2><p><strong>调用时机的不同</strong></p><ol><li><code>useLayoutEffect</code> 与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 的调用阶段是一样的。</li><li>在浏览器完成布局与绘制<strong>之后</strong>，传给 <code>useEffect</code> 的函数会延迟调用。</li></ol><p>🌰举例说明useEffect和useLayoutEffect的调用时机不同：</p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token comment">// Parent.jsx</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Child <span class="token keyword">from</span> <span class="token string">&quot;./Child&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;[Parent] componentDidMount&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Child.jsx</span>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useEffect<span class="token punctuation">,</span> useLayoutEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;[Child] useEffect mount&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;[Child] useLayoutEffect mount&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Child</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>🙋 <em><strong>Answer：</strong></em> 上述案例的日志结果如下。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[Child] useLayoutEffect mount   // 子组件挂载完成
[Parent] componentDidMount		// 父组件挂载完成
[Child] useEffect mount			// useEffect延迟调用了
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="什么情况下使用uselayouteffect" tabindex="-1"><a class="header-anchor" href="#什么情况下使用uselayouteffect" aria-hidden="true">#</a> 什么情况下使用useLayoutEffect？</h2><p>在浏览器执行下一次绘制前，用户可见的 DOM 变更必须同步执行，这样用户才不会感觉到视觉上的不一致 。</p>`,9);function m(h,g){const e=c("ExternalLinkIcon");return p(),u("div",null,[l,n("p",null,[s("详见"),n("a",d,[s("useLayoutEffect"),t(e)])]),r,n("blockquote",null,[k,n("p",null,[s("......服务端渲染相关内容，详见"),n("a",f,[s("useLayoutEffect"),t(e)])])]),v])}const y=o(i,[["render",m],["__file","useEffect和useLayoutEffect的区别.html.vue"]]);export{y as default};
