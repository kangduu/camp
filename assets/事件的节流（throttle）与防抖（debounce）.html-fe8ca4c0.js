const e=JSON.parse('{"key":"v-1cc5af2c","path":"/performance/%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89%E4%B8%8E%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89.html","title":"事件的节流（throttle）与防抖（debounce）","lang":"zh-CN","frontmatter":{"description":"事件的节流（throttle）与防抖（debounce） 上一节我们一起通过监听滚动事件，实现了各大网站喜闻乐见的懒加载效果。但我们提到，scroll 事件是一个非常容易被反复触发的事件。其实不止 scroll 事件，resize 事件、鼠标事件（比如 mousemove、mouseover 等）、键盘事件（keyup、keydown 等）都存在被频繁触发的风险。 频繁触发回调导致的大量计算会引发页面的抖动甚至卡顿。为了规避这种情况，我们需要一些手段来控制事件被触发的频率。就是在这样的背景下，throttle（事件节流）和 debounce（事件防抖）出现了。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/camps/performance/%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89%E4%B8%8E%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"杜同学日记"}],["meta",{"property":"og:title","content":"事件的节流（throttle）与防抖（debounce）"}],["meta",{"property":"og:description","content":"事件的节流（throttle）与防抖（debounce） 上一节我们一起通过监听滚动事件，实现了各大网站喜闻乐见的懒加载效果。但我们提到，scroll 事件是一个非常容易被反复触发的事件。其实不止 scroll 事件，resize 事件、鼠标事件（比如 mousemove、mouseover 等）、键盘事件（keyup、keydown 等）都存在被频繁触发的风险。 频繁触发回调导致的大量计算会引发页面的抖动甚至卡顿。为了规避这种情况，我们需要一些手段来控制事件被触发的频率。就是在这样的背景下，throttle（事件节流）和 debounce（事件防抖）出现了。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-26T14:05:38.000Z"}],["meta",{"property":"article:author","content":"kangduu"}],["meta",{"property":"article:modified_time","content":"2025-02-26T14:05:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"事件的节流（throttle）与防抖（debounce）\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-26T14:05:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kangduu\\",\\"url\\":\\"https://github.com/kangduu\\"}]}"]]},"headers":[{"level":2,"title":"“节流”与“防抖”的本质","slug":"节流-与-防抖-的本质","link":"#节流-与-防抖-的本质","children":[]},{"level":2,"title":"Throttle： 第一个人说了算","slug":"throttle-第一个人说了算","link":"#throttle-第一个人说了算","children":[]},{"level":2,"title":"Debounce： 最后一个人说了算","slug":"debounce-最后一个人说了算","link":"#debounce-最后一个人说了算","children":[]},{"level":2,"title":"用 Throttle 来优化 Debounce","slug":"用-throttle-来优化-debounce","link":"#用-throttle-来优化-debounce","children":[]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1740578738000,"updatedTime":1740578738000,"contributors":[{"name":"kangduu","email":"dukang1127@163.com","commits":1}]},"readingTime":{"minutes":6.63,"words":1989},"filePathRelative":"performance/事件的节流（throttle）与防抖（debounce）.md","localizedDate":"2025年2月26日","excerpt":"<h1> 事件的节流（throttle）与防抖（debounce）</h1>\\n<p>上一节我们一起通过监听滚动事件，实现了各大网站喜闻乐见的懒加载效果。但我们提到，scroll 事件是一个非常容易被反复触发的事件。其实不止 scroll 事件，resize 事件、鼠标事件（比如 mousemove、mouseover 等）、键盘事件（keyup、keydown 等）都存在被频繁触发的风险。</p>\\n<p>频繁触发回调导致的大量计算会引发页面的抖动甚至卡顿。为了规避这种情况，我们需要一些手段来控制事件被触发的频率。就是在这样的背景下，throttle（事件节流）和 debounce（事件防抖）出现了。</p>","autoDesc":true}');export{e as data};
