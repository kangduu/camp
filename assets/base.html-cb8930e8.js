const e=JSON.parse('{"key":"v-4db496ad","path":"/webpack/base.html","title":"","lang":"zh-CN","frontmatter":{"description":"webpack模块打包运行原理？ 首先我们应该简单了解一下webpack的整个打包流程： 读取webpack的配置参数； 启动webpack，创建Compiler对象并开始解析项目； 从入口文件（entry）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树； 对不同文件类型的依赖模块文件使用对应的Loader进行编译，最终转为Javascript文件； 整个过程中webpack会通过发布订阅模式，向外抛出一些hooks，而webpack的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/camps/webpack/base.html"}],["meta",{"property":"og:site_name","content":"杜同学日记"}],["meta",{"property":"og:description","content":"webpack模块打包运行原理？ 首先我们应该简单了解一下webpack的整个打包流程： 读取webpack的配置参数； 启动webpack，创建Compiler对象并开始解析项目； 从入口文件（entry）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树； 对不同文件类型的依赖模块文件使用对应的Loader进行编译，最终转为Javascript文件； 整个过程中webpack会通过发布订阅模式，向外抛出一些hooks，而webpack的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-27T07:17:52.000Z"}],["meta",{"property":"article:author","content":"kangduu"}],["meta",{"property":"article:modified_time","content":"2025-02-27T07:17:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-27T07:17:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kangduu\\",\\"url\\":\\"https://github.com/kangduu\\"}]}"]]},"headers":[{"level":2,"title":"webpack模块打包运行原理？","slug":"webpack模块打包运行原理","link":"#webpack模块打包运行原理","children":[]}],"git":{"createdTime":1740640672000,"updatedTime":1740640672000,"contributors":[{"name":"Seven","email":"74498826+kangduu@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":2.6,"words":779},"filePathRelative":"webpack/base.md","localizedDate":"2025年2月27日","excerpt":"<h2> webpack模块打包运行原理？</h2>\\n<p>首先我们应该简单了解一下webpack的整个打包流程：</p>\\n<ol>\\n<li>读取webpack的配置参数；</li>\\n<li>启动webpack，创建Compiler对象并开始解析项目；</li>\\n<li>从入口文件（entry）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；</li>\\n<li>对不同文件类型的依赖模块文件使用对应的Loader进行编译，最终转为Javascript文件；</li>\\n<li>整个过程中webpack会通过发布订阅模式，向外抛出一些hooks，而webpack的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。</li>\\n</ol>","autoDesc":true}');export{e as data};
