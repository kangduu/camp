import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o,c as i,a as n,b as s,d as t,e as c}from"./app-c5a91522.js";const l="/camps/assets/event.loop-efedec12.png",r={},u=c('<h2 id="浏览器环境下javascript引擎的事件循环机制" tabindex="-1"><a class="header-anchor" href="#浏览器环境下javascript引擎的事件循环机制" aria-hidden="true">#</a> 浏览器环境下JavaScript引擎的事件循环机制</h2><p>开始学习事件循环之前，让我们先看看下面几个问题。</p><ul><li>JavaScript 为什么是单线程的？</li><li>JavaScript 为什么需要异步？</li><li>JavaScript 单线程又是如何实现异步的？</li></ul><h3 id="javascript-为什么是单线程的❓" tabindex="-1"><a class="header-anchor" href="#javascript-为什么是单线程的❓" aria-hidden="true">#</a> JavaScript 为什么是单线程的❓</h3><p>单线程的意思简单理解就是“同一时间只能做一件事”，而JavaScript设计之初就是用在浏览器的脚本语言，这就与JavaScript的用途有着密不可分的关系。</p><p>作为浏览器脚本语言，JavaScript主要用于用户交互、DOM操作，这就要求我们不能同时去修改同一个DOM元素的内容或样式。假如现在有两个线程，A线程修改DOM的文本颜色为红色，B线程修改DOM的文本颜色为蓝色，那么浏览器应该选择渲染红色还是蓝色啦？所以，JavaScript只能是单线程的。</p><h5 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读" aria-hidden="true">#</a> 拓展阅读</h5><p>📣Web Worker 允许JavaScript脚本创建多个线程</p><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><p>📣浏览器无响应？（假死）</p><p>常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</p><p>JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p><h3 id="javascript-为什么需要异步❓" tabindex="-1"><a class="header-anchor" href="#javascript-为什么需要异步❓" aria-hidden="true">#</a> JavaScript 为什么需要异步❓</h3><p>前面我们已经明白了JavaScript为什么是单线程的，但是单线程存在的问题就是“当前任务执行时，后面的任务必须等待当前任务执行结束”。这样自上而下执行的特点，当某一行执行时间太长，将会出现代码阻塞的情况，呈现给用户的结果就是“卡死”的效果。</p><p>所以，在遇到一个异步事件，JavaScript引擎并不会一直等待异步事件返回结果，而是将这个事件挂载到与执行栈不同的任务队列。</p><h3 id="javascript-单线程又是如何实现异步的❓" tabindex="-1"><a class="header-anchor" href="#javascript-单线程又是如何实现异步的❓" aria-hidden="true">#</a> JavaScript 单线程又是如何实现异步的❓</h3><p>事件循环 Event Loop 。</p><h3 id="栈、堆和队列数据结构" tabindex="-1"><a class="header-anchor" href="#栈、堆和队列数据结构" aria-hidden="true">#</a> 栈、堆和队列数据结构</h3><ul><li>队列：先进先出。类似排队，总是按照先后顺序执行。</li><li>栈：先进后出。类似杯子，先放进去的总是最后才能取出。这种结构适用于需要根据优先级执行的任务。</li><li>堆：树状结构。类似图书馆书架，根据不同分类按照对应索引值取值。</li></ul><h3 id="执行栈和任务队列" tabindex="-1"><a class="header-anchor" href="#执行栈和任务队列" aria-hidden="true">#</a> 执行栈和任务队列</h3><h5 id="执行栈" tabindex="-1"><a class="header-anchor" href="#执行栈" aria-hidden="true">#</a> 执行栈</h5><p>JavaScript代码执行的时候会将不同的变量存于内存中的堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象，而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的<strong>执行栈</strong>和上面这个<strong>栈</strong>的意义却有些不同。</p><p>当我们调用一个方法的时候，JavaScript会生成一个与这个方法对应的执行环境（context），又叫<strong>执行上下文</strong>。这个执行环境中存着这个方法的<u>私有作用域</u>，<u>上层作用域的指向</u>，<u>方法的参数</u>，这个<u>作用域中定义的变量</u>以及这个<u>作用域的this对象</u>。 而当一系列方法被依次调用的时候，因为JavaScript是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p><p>当一个脚本第一次执行的时候，JavaScript引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么JavaScript会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，JavaScript会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p><h5 id="任务队列" tabindex="-1"><a class="header-anchor" href="#任务队列" aria-hidden="true">#</a> 任务队列</h5><p>&quot;任务队列&quot;是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在&quot;任务队列&quot;中添加一个事件，表示相关的异步任务可以进入&quot;执行栈&quot;了。主线程读取&quot;任务队列&quot;，就是读取里面有哪些事件。</p><p>&quot;任务队列&quot;中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入&quot;任务队列&quot;，等待主线程读取。</p><p>&quot;任务队列&quot;是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，&quot;任务队列&quot;上第一位的事件就自动进入主线程。但是，由于存在后文提到的&quot;定时器&quot;功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p><p>读取到一个异步任务，首先是将异步任务放进事件表格（Event table）中，当放进事件表格中的异步任务完成某种事情或者说达成某些条件（如setTimeout事件到了，鼠标点击了，数据文件获取到了）之后，才将这些异步任务推入事件队列（Event Queue)中，这时候的异步任务才是执行栈中空闲的时候才能读取到的异步任务。<strong>一句话总结就是，异步任务进入Event table，当任务执行回调后，才进入事件队列，等待执行栈读取。</strong></p><h5 id="任务队列本质" tabindex="-1"><a class="header-anchor" href="#任务队列本质" aria-hidden="true">#</a> 任务队列本质</h5><p>👣所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。【只有一个执行栈】</p><p>👣主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件，排队等待执行栈读取执行。</p><p>👣一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务便<strong>结束等待状态</strong>，进入执行栈，开始执行。</p><p>👣主线程不断重复上一步操作。</p><h3 id="宏任务和微任务" tabindex="-1"><a class="header-anchor" href="#宏任务和微任务" aria-hidden="true">#</a> 宏任务和微任务</h3><h5 id="宏任务-浏览器" tabindex="-1"><a class="header-anchor" href="#宏任务-浏览器" aria-hidden="true">#</a> 宏任务（浏览器）</h5><ul><li>渲染事件：DOM解析、布局、绘制等</li><li>用户交互事件：点击、输入、滚动、缩放等</li><li>script事件：js执行、网络请求、文件读取（i/o）、Ajax请求等</li><li>定时器： <code>setTimeout</code>，<code>setInterval</code></li></ul><h5 id="微任务-浏览器" tabindex="-1"><a class="header-anchor" href="#微任务-浏览器" aria-hidden="true">#</a> 微任务（浏览器）</h5><ul><li>使用MutationObserver监控某个DOM节点，然后通过JavaScript修改这个节点，当DOM节点发送变化时，就会产生DOM变化记录的微任务</li><li>使用Promise，调用Promise.resolve()或Promise.reject()时也会产生微任务</li></ul><h5 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h5><ol><li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列；</li><li>微任务的执行时长会影响当前宏任务的时长（多个微任务时长累加）；</li><li><strong>在一个宏任务中，如果创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。【任务执行顺序】</strong></li></ol><h3 id="事件循环机制流程" tabindex="-1"><a class="header-anchor" href="#事件循环机制流程" aria-hidden="true">#</a> 事件循环机制流程</h3><figure><img src="'+l+`" alt="Event Loop" tabindex="0" loading="lazy"><figcaption>Event Loop</figcaption></figure><ol><li>主线程执行JavaScript整体代码，形成一个执行栈，在遇到任务源时将其所指定的异步任务挂起，接受到响应结果后将异步任务放入对应的任务队列中，直到执行栈只剩全局上下文；</li><li>将微任务队列中的所有任务按优先级、单个任务的异步任务入栈并执行，直到清空所有的微任务队列；</li><li>将宏任务队列中的优先级最高的任务队列中的异步任务入栈并执行；</li><li>重复第 2 3 步骤，直到清空所有的宏任务队列和微任务队列，全局执行上下文出栈。</li></ol><p>❗<strong>注意：任务源所指定的异步任务，并不是立即被放入任务队列中，而是在接收到响应结果后才会将其放入任务队列中排队。</strong></p><p>例如：setTimeout指定延迟时间为1s，则在1s后才会将该任务源所指定的任务队列放入队列中。</p><h3 id="试题分析" tabindex="-1"><a class="header-anchor" href="#试题分析" aria-hidden="true">#</a> 试题分析</h3><p>🌰下面的代码输出什么？为什么？并阐述其中的原理？</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;async1 start&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;async1 end&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;async2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;script start&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;setTimeout&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;promise1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;promise2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;script end&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><h5 id="👀关键字" tabindex="-1"><a class="header-anchor" href="#👀关键字" aria-hidden="true">#</a> 👀<strong>关键字</strong></h5><p>进程、线程、同步、异步、阻塞、非阻塞、事件循环、栈、堆、队列、任务源、宏任务、微任务、执行上下文</p><h5 id="🔗参考" tabindex="-1"><a class="header-anchor" href="#🔗参考" aria-hidden="true">#</a> 🔗<strong>参考</strong></h5>`,53),d={href:"http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html",target:"_blank",rel:"noopener noreferrer"},h={href:"http://www.ruanyifeng.com/blog/2013/10/event_loop.html",target:"_blank",rel:"noopener noreferrer"},k={href:"http://www.ruanyifeng.com/blog/2014/10/event-loop.html",target:"_blank",rel:"noopener noreferrer"},v={href:"https://segmentfault.com/a/1190000022511727",target:"_blank",rel:"noopener noreferrer"};function f(m,b){const a=p("ExternalLinkIcon");return o(),i("div",null,[u,n("ul",null,[n("li",null,[n("a",d,[s("进程与线程的一个简单解释"),t(a)])]),n("li",null,[n("a",h,[s("什么是 Event Loop ？"),t(a)])]),n("li",null,[n("a",k,[s("JavaScript 运行机制详解"),t(a)])]),n("li",null,[n("a",v,[s("[浏览器之JS引擎工作机制&事件循环]"),t(a)])])])])}const x=e(r,[["render",f],["__file","event.loop.html.vue"]]);export{x as default};
