const e=JSON.parse('{"key":"v-e02a086e","path":"/javascript/","title":"JavaScript","lang":"zh-CN","frontmatter":{"title":"JavaScript","icon":"fa6-brands:square-js","description":"分时函数 为什么会有分时函数啦？ ​ 防抖和节流是对重复或频繁触发的任务控制，移除部分操作，只执行最后一次或每隔一段时间执行一次。 ​ 分时函数同样是多任务，但是不让其一次执行完，而是每一段时间执行一部分。比如添加 dom 节点，一次需要条件 100 个，可分为 10 次，一次 10 个。 ​ 分时函数主要是解决页面一次渲染数据（或节点）太多，导致页面卡顿或假死现象。 分时函数案例 首先我们来看一个案例，通过循环添加了 1000 个 div。其中处理数据少，当每一个元素都需要请求计算数据是，消耗无比的大。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/camp/javascript/"}],["meta",{"property":"og:site_name","content":"杜同学日记"}],["meta",{"property":"og:title","content":"JavaScript"}],["meta",{"property":"og:description","content":"分时函数 为什么会有分时函数啦？ ​ 防抖和节流是对重复或频繁触发的任务控制，移除部分操作，只执行最后一次或每隔一段时间执行一次。 ​ 分时函数同样是多任务，但是不让其一次执行完，而是每一段时间执行一部分。比如添加 dom 节点，一次需要条件 100 个，可分为 10 次，一次 10 个。 ​ 分时函数主要是解决页面一次渲染数据（或节点）太多，导致页面卡顿或假死现象。 分时函数案例 首先我们来看一个案例，通过循环添加了 1000 个 div。其中处理数据少，当每一个元素都需要请求计算数据是，消耗无比的大。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-25T09:52:13.000Z"}],["meta",{"property":"article:author","content":"kangduu"}],["meta",{"property":"article:modified_time","content":"2024-12-25T09:52:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JavaScript\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-25T09:52:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kangduu\\",\\"url\\":\\"https://github.com/kangduu\\"}]}"]]},"headers":[{"level":2,"title":"分时函数","slug":"分时函数","link":"#分时函数","children":[{"level":3,"title":"为什么会有分时函数啦？","slug":"为什么会有分时函数啦","link":"#为什么会有分时函数啦","children":[]},{"level":3,"title":"分时函数案例","slug":"分时函数案例","link":"#分时函数案例","children":[]},{"level":3,"title":"解决思路","slug":"解决思路","link":"#解决思路","children":[]}]},{"level":2,"title":"惰性加载-不重复判断","slug":"惰性加载-不重复判断","link":"#惰性加载-不重复判断","children":[{"level":3,"title":"惰性加载存在的意义","slug":"惰性加载存在的意义","link":"#惰性加载存在的意义","children":[]},{"level":3,"title":"案例佐证","slug":"案例佐证","link":"#案例佐证","children":[]}]},{"level":2,"title":"高阶函数（higher-order-function）","slug":"高阶函数-higher-order-function","link":"#高阶函数-higher-order-function","children":[{"level":3,"title":"作为参数","slug":"作为参数","link":"#作为参数","children":[]},{"level":3,"title":"作为返回值 - 类型判断——Object.prototype.toString.call(target)","slug":"作为返回值-类型判断——object-prototype-tostring-call-target","link":"#作为返回值-类型判断——object-prototype-tostring-call-target","children":[]},{"level":3,"title":"作为返回值 - 预置函数——当目标条件满足才执行回调函数","slug":"作为返回值-预置函数——当目标条件满足才执行回调函数","link":"#作为返回值-预置函数——当目标条件满足才执行回调函数","children":[]},{"level":3,"title":"作为返回值 - 装饰者模式","slug":"作为返回值-装饰者模式","link":"#作为返回值-装饰者模式","children":[]},{"level":3,"title":"作为返回值 - 单列模式","slug":"作为返回值-单列模式","link":"#作为返回值-单列模式","children":[]},{"level":3,"title":"其它应用","slug":"其它应用","link":"#其它应用","children":[]}]}],"git":{"createdTime":1734848484000,"updatedTime":1735120333000,"contributors":[{"name":"dukang","email":"dk@nosugartech.com","commits":1},{"name":"kangduu","email":"dukang1127@163.com","commits":1}]},"readingTime":{"minutes":4.57,"words":1372},"filePathRelative":"javascript/README.md","localizedDate":"2024年12月22日","excerpt":"<h2> 分时函数</h2>\\n<h3> 为什么会有分时函数啦？</h3>\\n<p>​ 防抖和节流是对重复或频繁触发的任务控制，移除部分操作，只执行最后一次或每隔一段时间执行一次。</p>\\n<p>​ 分时函数同样是<strong>多任务，但是不让其一次执行完，而是每一段时间执行一部分</strong>。比如添加 dom 节点，一次需要条件 100 个，可分为 10 次，一次 10 个。</p>\\n<p>​ 分时函数主要是<strong>解决页面一次渲染数据（或节点）太多，导致页面卡顿或假死现象</strong>。</p>\\n<h3> 分时函数案例</h3>\\n<p>首先我们来看一个案例，通过循环添加了 1000 个 div。其中处理数据少，当每一个元素都需要请求计算数据是，消耗无比的大。</p>","autoDesc":true}');export{e as data};
