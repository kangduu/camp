import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as l,c as a,a as e,b as t,d as n,e as s}from"./app-76087117.js";const c={},d=e("h3",{id:"http-缓存机制",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#http-缓存机制","aria-hidden":"true"},"#"),t(" http 缓存机制")],-1),h={href:"https://blog.csdn.net/jutal_ljt/article/details/80021545",target:"_blank",rel:"noopener noreferrer"},p={href:"https://blog.csdn.net/jutal_ljt/article/details/80021545",target:"_blank",rel:"noopener noreferrer"},S=s('<h3 id="http-和-https" tabindex="-1"><a class="header-anchor" href="#http-和-https" aria-hidden="true">#</a> http 和 https</h3><ul><li><p>http</p><blockquote><p>超文本传输协议</p><p>以<code>明文方式</code>发送内容，不提供任何方式的数据加密，</p><p>如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP 协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p></blockquote></li><li><p>https</p><blockquote><p>安全套接字超文本传输协议</p><p>HTTPS 在 HTTP 的基础上加入了 SSL/TLS 协议</p><p>SSL/TLS 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密</p><p>HTTPS 协议是由 SSL/TLS+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全</p><p>HTTPS<code>并非绝对安全</code>，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但 HTTPS 仍是现行架构下最安全的解决方案</p></blockquote></li><li><p>HTTPS 协议的主要作用</p><blockquote><p>建立一个信息安全通道，来保证数据传输的安全</p><p>确认网站的真实性。</p></blockquote></li></ul><h3 id="http-与-https-的区别" tabindex="-1"><a class="header-anchor" href="#http-与-https-的区别" aria-hidden="true">#</a> http 与 https 的区别</h3><ol><li>https 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用。</li><li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl/tls 加密传输协议。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL/TLS+HTTP 协议构建的可进行加密传输、身份认证</li></ol><h3 id="https-的缺点" tabindex="-1"><a class="header-anchor" href="#https-的缺点" aria-hidden="true">#</a> HTTPS 的缺点</h3><ol><li>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10%到 20%的耗电</li><li>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响</li><li>SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用</li><li>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗</li><li>HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行</li></ol><h3 id="get-与-post-的区别" tabindex="-1"><a class="header-anchor" href="#get-与-post-的区别" aria-hidden="true">#</a> GET 与 POST 的区别</h3><ol><li>Get 请求能<code>缓存</code>，Post 不能</li><li>Post 相对 Get <code>安全</code>一点点，因为 Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会。但是在抓包的情况下都是一样的。</li><li>Post 可以通过 <code>request body</code>来传输比 Get <code>更多的数据</code>，Get 没有这个技术</li><li><code>URL有长度限制</code>，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li><li>Post 支持更多的<code>编码类型</code>且不对数据类型限制</li></ol><h2 id="tcp-的三次握手四次挥手-画在纸上。" tabindex="-1"><a class="header-anchor" href="#tcp-的三次握手四次挥手-画在纸上。" aria-hidden="true">#</a> TCP 的三次握手四次挥手，画在纸上。</h2><h4 id="tcp-标志位" tabindex="-1"><a class="header-anchor" href="#tcp-标志位" aria-hidden="true">#</a> TCP 标志位</h4><ol><li>ACK(acknowledgement 确认)</li><li>PSH(push 传送)</li><li>FIN(finish 结束)</li><li>RST(reset 重置)</li><li>URG(urgent 紧急)</li><li>SYN(synchronous 建立联机 同步)</li><li>Sequence Number(顺序号码 seq)</li><li>Acknowledge Number(确认号码 ack)</li></ol><h4 id="tcp-三次握手-建立连接" tabindex="-1"><a class="header-anchor" href="#tcp-三次握手-建立连接" aria-hidden="true">#</a> TCP 三次握手（建立连接）</h4><ul><li><p><strong>第一次握手</strong>——客户端将标志位 SYN（synchronize 同步）置为 1，随机产生一个值为 seq=J 的数据包发送到服务器，此后客户端进入<code>SYN_SENT</code>状态，等待服务端确认；</p></li><li><p><strong>第二次握手</strong>——服务端接收到数据包后由标志位 SYN=1 知道客户端请求建立连接，然后服务端将标志位 SYN 和 ASK（acknowledgement 确认）都置为 1，ack=J+1，随机产生一个 seq=K，并将该数据包发送给客户端以回应确认连接请求，此后服务端进入<code>SYN_RCVD</code>状态；</p></li><li><p><strong>第三次握手</strong>——客户端收到确认后，检查<strong>ack 是否为 J+1</strong>（ J=seq，是由客户端第一次发送过去的），ACK 是否为 1（<strong>true</strong>），如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给服务端 B，服务端 B 检查<strong>ack 是否为 K+1</strong>（ K=seq,是服务端返回的），ACK 是否为 1，如果正确则连接建立成功，**客户端 A 和服务端 B 进入<code>ESTABLISHED</code>状态，**完成三次握手。</p><p>随后客户端 A 与服务端 B 之间可以开始传输数据了。</p></li></ul><h4 id="为什么需要三次握手" tabindex="-1"><a class="header-anchor" href="#为什么需要三次握手" aria-hidden="true">#</a> 为什么需要三次握手</h4><p>​ 在《计算机网络》第四版中是这样说的：“三次握手”的<code>目的</code>是“<strong>为了防止<u>已失效的连接请求报文段</u>突然又传送到了服务端，因而产生错误</strong>”</p><p>**何为“已失效的连接请求报文段”啦？**举个栗子——client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致<u>延误到连接释放以后的某个时间才到达 server</u>。本来这是一个早已失效的报文段，但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。这不符合正常逻辑，对吧。</p><p><strong>假设不采用“三次握手”，会是什么样的情况啦？</strong>——如果 server 发出确认，新的连接就建立，但是 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。自以为是的 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。再来一种，还是刚才的栗子——如果 client 不会向 server 的确认发出确认（第三次握手），server 由于收不到确认，就知道 client 并没有确认建立连接，则会一直等待，知道某种机制使其断开。所以采用“三次握手”的办法可以防止上述现象发生，主要目的防止 server 端一直等待，浪费资源。</p><h4 id="tcp-四次挥手-关闭连接" tabindex="-1"><a class="header-anchor" href="#tcp-四次挥手-关闭连接" aria-hidden="true">#</a> TCP 四次挥手（关闭连接）</h4><ul><li><strong>第一次挥手</strong>——Client 发送一个<strong>FIN（finish 结束）</strong>，用来<strong>关闭 Client 到 Server 的数据传送</strong>，Client 进入<code>FIN_WAIT_1</code>状态。【等待服务端回应是否收到关闭连接的信号】</li><li><strong>第二次挥手</strong>——Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号），Server 进入<code>CLOSE_WAIT</code>状态。【可以理解为，“服务端说：嘿，客户端，我收到关闭连接的信号，你先等着，我去通知应用程序关闭。客户端说：我已知晓，继续等待中...... （不会回复）】</li><li><strong>第三次挥手</strong>——Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入<code>LAST_ACK</code>状态。【服务端告诉客户端，我已关闭了，并等待客户端的确认信息】</li><li><strong>第四次挥手</strong>——Client 收到 FIN 后，Client 进入<code>TIME_WAIT</code>状态，接着发送一个 ACK 给 Server，确认序号为收到序号+1，Server 进入<code>CLOSED</code>状态，完成四次挥手。</li></ul><p>【问题 1】<code>TIME_WAIT</code>状态的作用是什么？为什么是 <strong>等待 2MSL</strong> （Maximum Segment Lifetime ，报文最大生存时间）？</p><p>【答】</p><p>​ 按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可能最后一个 ACK 丢失。所以<code>TIME_WAIT</code>状态就是用来重发可能丢失的 ACK 报文。</p><h4 id="为什么建立连接是三次握手-而断开连接需要四次挥手" tabindex="-1"><a class="header-anchor" href="#为什么建立连接是三次握手-而断开连接需要四次挥手" aria-hidden="true">#</a> 为什么建立连接是三次握手，而断开连接需要四次挥手?</h4><p>​ 服务端在<code>LISTEN</code>状态下(建立连接)，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当<strong>服务端收到客户端的 FIN 报文时，仅仅表示客户端不再发送数据了但是还能接收数据，服务端也未必全部数据都发送给对方了</strong>，所以服务端可以立即 close，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，服务端 ACK 和 FIN 一般都会分开发送。</p><h4 id="http-连接到断开全过程" tabindex="-1"><a class="header-anchor" href="#http-连接到断开全过程" aria-hidden="true">#</a> http 连接到断开全过程</h4>',25);function T(u,g){const r=i("ExternalLinkIcon");return l(),a("div",null,[d,e("p",null,[e("a",h,[e("a",p,[t("https://blog.csdn.net/jutal_ljt/article/details/80021545"),n(r)])])]),S])}const P=o(c,[["render",T],["__file","归纳.html.vue"]]);export{P as default};
