const e=JSON.parse('{"key":"v-757d6b16","path":"/js/memory.leak.html","title":"内存泄漏","lang":"zh-CN","frontmatter":{"title":"内存泄漏","category":"javascript","description":"​ 内存泄漏指的是：任何对象在你不再拥有或不再需要之后任然存在。 不再拥有——（无法获取） 不再需要——（还存在隐性引用） 常见的内存泄漏 闭包 控制台日志 循环（两对象彼此引用且彼此保留） 事件监听，addEventListener 需要 removeEventListener 移除（传递给两者的函数必须一致） setTimeout/setInterval ，对应的使用 clearTimeout/clearInterval 清空 注意，使用 setTimeout 模拟 setInterval 循环调用会造成内存泄漏 如 Promise、rxjs 的 Observables、node 的 EventEmitters 这些方法，无回调函数或未取消监听都会造成内存泄漏 Promise 如果没有 resolved 或者 rejected，会连同 then()中的代码一起造成内存泄漏 在没有虚拟 dom 的计算下实现了无无限滚动，那么 dom 节点的数量将无限增加 IntersectionObserver, ResizeObserver, MutationObserver 这些新的事件监听 Api，都必须使用对应的 disconnect 取消监听 同 redux、vuex 这样挂载在全局的状态管理，如果不注意内存的占用，则会持续增加不会被释放","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/camp/js/memory.leak.html"}],["meta",{"property":"og:site_name","content":"杜同学日记"}],["meta",{"property":"og:title","content":"内存泄漏"}],["meta",{"property":"og:description","content":"​ 内存泄漏指的是：任何对象在你不再拥有或不再需要之后任然存在。 不再拥有——（无法获取） 不再需要——（还存在隐性引用） 常见的内存泄漏 闭包 控制台日志 循环（两对象彼此引用且彼此保留） 事件监听，addEventListener 需要 removeEventListener 移除（传递给两者的函数必须一致） setTimeout/setInterval ，对应的使用 clearTimeout/clearInterval 清空 注意，使用 setTimeout 模拟 setInterval 循环调用会造成内存泄漏 如 Promise、rxjs 的 Observables、node 的 EventEmitters 这些方法，无回调函数或未取消监听都会造成内存泄漏 Promise 如果没有 resolved 或者 rejected，会连同 then()中的代码一起造成内存泄漏 在没有虚拟 dom 的计算下实现了无无限滚动，那么 dom 节点的数量将无限增加 IntersectionObserver, ResizeObserver, MutationObserver 这些新的事件监听 Api，都必须使用对应的 disconnect 取消监听 同 redux、vuex 这样挂载在全局的状态管理，如果不注意内存的占用，则会持续增加不会被释放"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-12T08:20:45.000Z"}],["meta",{"property":"article:author","content":"kangduu"}],["meta",{"property":"article:modified_time","content":"2025-06-12T08:20:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存泄漏\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-12T08:20:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kangduu\\",\\"url\\":\\"https://github.com/kangduu\\"}]}"]]},"headers":[{"level":2,"title":"常见的内存泄漏","slug":"常见的内存泄漏","link":"#常见的内存泄漏","children":[]},{"level":2,"title":"容易引起内存使用不当的场景","slug":"容易引起内存使用不当的场景","link":"#容易引起内存使用不当的场景","children":[]},{"level":2,"title":"V8 引擎","slug":"v8-引擎","link":"#v8-引擎","children":[{"level":3,"title":"内存何时回收","slug":"内存何时回收","link":"#内存何时回收","children":[]},{"level":3,"title":"名词解释","slug":"名词解释","link":"#名词解释","children":[]},{"level":3,"title":"内存大小","slug":"内存大小","link":"#内存大小","children":[]},{"level":3,"title":"内存分配","slug":"内存分配","link":"#内存分配","children":[]},{"level":3,"title":"如何查看内存","slug":"如何查看内存","link":"#如何查看内存","children":[]}]},{"level":2,"title":"QA","slug":"qa","link":"#qa","children":[]}],"git":{"createdTime":1749716445000,"updatedTime":1749716445000,"contributors":[{"name":"dukang","email":"dk@nosugartech.com","commits":1}]},"readingTime":{"minutes":2.56,"words":768},"filePathRelative":"js/memory.leak.md","localizedDate":"2025年6月12日","excerpt":"<p>​ 内存泄漏指的是：<strong>任何对象在你不再拥有或不再需要之后任然存在</strong>。</p>\\n<ul>\\n<li>不再拥有——（无法获取）</li>\\n<li>不再需要——（还存在隐性引用）</li>\\n</ul>\\n<h2> 常见的内存泄漏</h2>\\n<ol>\\n<li>闭包</li>\\n<li>控制台日志</li>\\n<li>循环（两对象彼此引用且彼此保留）</li>\\n<li>事件监听，addEventListener 需要 removeEventListener 移除（<strong>传递给两者的函数必须一致</strong>）</li>\\n<li>setTimeout/setInterval ，对应的使用 clearTimeout/clearInterval 清空</li>\\n<li><strong>注意，使用 setTimeout 模拟 setInterval 循环调用会造成内存泄漏</strong></li>\\n<li>如 Promise、rxjs 的 Observables、node 的 EventEmitters 这些方法，无回调函数或未取消监听都会造成内存泄漏</li>\\n<li>Promise 如果没有 resolved 或者 rejected，会连同 then()中的代码一起造成内存泄漏</li>\\n<li>在没有虚拟 dom 的计算下实现了无无限滚动，那么 dom 节点的数量将无限增加</li>\\n<li><a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">IntersectionObserver</a>, <a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ResizeObserver</a>, <a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">MutationObserver</a> 这些新的事件监听 Api，都必须使用对应的 disconnect 取消监听</li>\\n<li>同 redux、vuex 这样<strong>挂载在全局的状态管理，如果不注意内存的占用，则会持续增加不会被释放</strong></li>\\n</ol>","autoDesc":true}');export{e as data};
