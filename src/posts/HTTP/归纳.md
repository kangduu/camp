---
title: http你应该知道的知识点
---

### http缓存机制

[<https://blog.csdn.net/jutal_ljt/article/details/80021545>](https://blog.csdn.net/jutal_ljt/article/details/80021545)

### http和https

- http

  > 超文本传输协议
  >
  > 以`明文方式`发送内容，不提供任何方式的数据加密，
  >
  > 如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

- https

  > 安全套接字超文本传输协议
  >
  > HTTPS在HTTP的基础上加入了SSL/TLS协议
  >
  > SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密
  >
  > HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全
  >
  > HTTPS`并非绝对安全`，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案


- HTTPS协议的主要作用

  > 建立一个信息安全通道，来保证数据传输的安全
  >
  > 确认网站的真实性。

### http与https的区别

1. https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证

### HTTPS的缺点

1. HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电
2. HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响
3. SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用
4. SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗
5. HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行

### GET与POST 的区别

1. Get 请求能`缓存`，Post 不能
2. Post 相对 Get `安全`一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会。但是在抓包的情况下都是一样的。
3. Post 可以通过 `request body`来传输比 Get `更多的数据`，Get 没有这个技术
4. `URL有长度限制`，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
5. Post 支持更多的`编码类型`且不对数据类型限制

## TCP的三次握手四次挥手，画在纸上。

#### TCP标志位

1. ACK(acknowledgement 确认)
2. PSH(push传送)
3. FIN(finish结束)
4. RST(reset重置)
5. URG(urgent紧急)
6. SYN(synchronous建立联机 同步)
7. Sequence Number(顺序号码 seq)
8. Acknowledge Number(确认号码 ack)

#### TCP三次握手（建立连接）

- **第一次握手**——客户端将标志位SYN（synchronize 同步）置为1，随机产生一个值为seq=J的数据包发送到服务器，此后客户端进入`SYN_SENT`状态，等待服务端确认；

- **第二次握手**——服务端接收到数据包后由标志位SYN=1知道客户端请求建立连接，然后服务端将标志位SYN和ASK（acknowledgement 确认）都置为1，ack=J+1，随机产生一个seq=K，并将该数据包发送给客户端以回应确认连接请求，此后服务端进入`SYN_RCVD`状态；

- **第三次握手**——客户端收到确认后，检查**ack是否为J+1**（ J=seq，是由客户端第一次发送过去的），ACK是否为1（**true**），如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查**ack是否为K+1**（ K=seq,是服务端返回的），ACK是否为1，如果正确则连接建立成功，**客户端A和服务端B进入`ESTABLISHED`状态，**完成三次握手。

  随后客户端A与服务端B之间可以开始传输数据了。

![](http://dukangblog.top/img/http.3.png)

#### 为什么需要三次握手

​	在《计算机网络》第四版中是这样说的：“三次握手”的`目的`是“**为了防止<u>已失效的连接请求报文段</u>突然又传送到了服务端，因而产生错误**”

  	**何为“已失效的连接请求报文段”啦？**举个栗子——client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致<u>延误到连接释放以后的某个时间才到达server</u>。本来这是一个早已失效的报文段，但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。这不符合正常逻辑，对吧。

　　**假设不采用“三次握手”，会是什么样的情况啦？**——如果server发出确认，新的连接就建立，但是client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。自以为是的server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。再来一种，还是刚才的栗子——如果client不会向server的确认发出确认（第三次握手），server由于收不到确认，就知道client并没有确认建立连接，则会一直等待，知道某种机制使其断开。所以采用“三次握手”的办法可以防止上述现象发生，主要目的防止server端一直等待，浪费资源。

#### TCP四次挥手（关闭连接）

- **第一次挥手**——Client发送一个**FIN（finish 结束）**，用来**关闭Client到Server的数据传送**，Client进入`FIN_WAIT_1`状态。【等待服务端回应是否收到关闭连接的信号】
- **第二次挥手**——Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入`CLOSE_WAIT`状态。【可以理解为，“服务端说：嘿，客户端，我收到关闭连接的信号，你先等着，我去通知应用程序关闭。客户端说：我已知晓，继续等待中...... （不会回复）】
- **第三次挥手**——Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入`LAST_ACK`状态。【服务端告诉客户端，我已关闭了，并等待客户端的确认信息】
- **第四次挥手**——Client收到FIN后，Client进入`TIME_WAIT`状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入`CLOSED`状态，完成四次挥手。

![](http://dukangblog.top/img/http.4.jpg)

【问题1】`TIME_WAIT`状态的作用是什么？为什么是 **等待 2MSL** （Maximum Segment Lifetime ，报文最大生存时间）？

【答】

​	按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以`TIME_WAIT`状态就是用来重发可能丢失的ACK报文。

#### 为什么建立连接是三次握手，而断开连接需要四次挥手?

​	服务端在`LISTEN`状态下(建立连接)，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当**服务端收到客户端的FIN报文时，仅仅表示客户端不再发送数据了但是还能接收数据，服务端也未必全部数据都发送给对方了**，所以服务端可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，服务端ACK和FIN一般都会分开发送。

#### http连接到断开全过程

![ http连接与断开全过程 ](http://dukangblog.top/img/http.3.4.jpg)
